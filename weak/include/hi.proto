syntax = "proto3";
package hiPb;

message Acn {
  uint64 nonce = 1;
  bytes code = 2;
  bytes codehash = 3;
  /*
    ðŸ¦œ : Because pb doesn't allow bytes as key, we kinda have to store the kv
    separately... So we used the following for storage, which is map<byte32, byte32>
   */
  repeated bytes storage_ks = 4;
  repeated bytes storage_vs = 5;
} // []

enum TxType{EVM = 0; DATA = 1;}

message Tx {
  TxType type = 1;
  bytes from_addr = 2;
  bytes to_addr = 3;
  bytes data = 4;
  uint64 timestamp = 5;
  uint64 nonce = 6;
  bytes hash = 7;               // will be serialized, but not parsed

  string pk_pem = 8;
  bytes signature = 9;          // key.sign(hash)
  bytes pk_crt = 10;            // ca_key.sign(pk_pem)
}                               // [x]

message BlkHeader {uint64 number = 1; bytes parentHash = 2; bytes hash = 3;}

message Blk {BlkHeader header = 1; repeated Tx txs = 2;} // [x]

message BlkForConsensus {BlkHeader header = 1; repeated bytes txhs = 2;}
message TxOnBlkInfo {uint64 blkNumber = 1; uint64 onBlkId = 2;}
message StateChange {bool del = 1; bytes k = 2; bytes v = 3;} // []
message StateChanges {repeated StateChange changes = 1;}            // []

message TxReceipt {bool ok = 1; bytes result = 2;} // []

// executed Blk
message ExecBlk {
  Blk blk = 1;
  repeated TxReceipt txReceipts = 2;
  repeated StateChanges stateChanges = 3;
} // []
