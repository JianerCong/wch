#pragma once
#include <algorithm>
// using std::string;

#include "core0.hpp"

namespace weak {

  using boost::lexical_cast;
  using std::function;




  // {{{ Interfaces


  /**
   * @brief Representing a type that can provide Acn.
   * The set of accounts is the canonical world state.
   */
  class IAcnGettable{
  public:
    virtual optional<Acn> getAcn(evmc::address addr) const noexcept=0;
  };


  /**
   * @brief A state change, should be generated by executor.
   */

  struct StateChange{bool del=false; string k; string v;};

  /**
   * @brief The interface drawn from `IWorldChainStateSettable`.
   *
   * ü¶ú : This is for RPC for now.
   */
  class IChainDBGettable {
  public:
    virtual optional<string> getFromChainDB(const string k) const =0;
  };

  /**
   * @brief The interface that `WorldStorage` exposes to `CoreManager`. It
   * allows the `CoreManager` to change
   *   - the *chain state* (e.g. Transaction info, Block info stored in chainDB)
   *   _ the *world state* (stored in stateDB)
   *
   *   ü¶ú: We see that the `CoreManager` is able to read/write chainDB (no
   *   deletion). This agree with fact that "blockchain is append only". On the
   *   other hand, StateDB can only be write/delete by the `CoreManager` because
   *   the state only need to be visible to the execution module.
   *
   *   üê¢: Are U sure that making the StateDB write-only to `CoreManager` is not
   *   being lazy?
   *
   *   ü¶ú: No.
   */
  class IWorldChainStateSettable: public virtual IChainDBGettable {
  public:
    virtual bool setInChainDB(const string k, const string v) =0;

    /// Apply the journal (state changes) to the stateDb, usually it's one
    /// journal per Blk.
    virtual bool applyJournalStateDB(const vector<StateChange> & j)=0;
  };

  /**
   * @brief The interface that `WorldStorage` exposes to get a series of keys
   * with certain prefix in the DB.
   *
   * üê¢ : This interface is created here initially for the initializer, who
   * needs to get all keys start which "/tx/" in order to figure out what Txs
   * have been written to the chain.
   */
class IChainDBPrefixKeyGettable {
public:
  virtual vector<string> getKeysStartWith(string_view prefix)const =0;
};

  /**
   * @brief The interface that sticks two interfaces.
   *
   * ü¶ú : Why?
   *
   * üê¢ : Sometimes it's easier to pass this around in functions. This is
   * created for `init`.
   */
class IChainDBGettable2 :public virtual IChainDBPrefixKeyGettable,
                         public virtual IChainDBGettable{};


  // }}}



class ITxExecutable {
  public:
    /**
     * @brief Probably the most important function that the execution module expose.
     *
     * If the execution is successful, a series of state-changes (called
     * "journal") and the execution-result is returned.
     *
     * @param w The read-only stateDb (world state).
     * @param t The transaction to be executed.
     * @return the pair (journal,result). {} if the execution fails.
     */
    virtual optional<tuple<vector<StateChange>,bytes>> executeTx(IAcnGettable * const w,
                                                                 const Tx & t) const noexcept = 0;
    // determine the type of tx: CREATE/CALL
    // Initialize host with the stateDb
    // Make VM
    // Execute and get result
    // If successful : make_tuple
  };


  // using std::move;



  /**
   * @brief The type that can get Tx by the corresponsing hash.
   *
   * This is usually used by a `BlkForConsensus` to convert to an actual `Blk`.
   */
  class IByHashTxGettable{
  public:
    virtual optional<Tx> getTxByHash(hash256 h) noexcept=0;
  };

  /**
   * @brief The interface of pool exposed to consensus's executor.
   *
   * ü¶ú : This is pretty much everything the consensus's executor need from pool.
   */
  class IPoolSettable : public virtual IByHashTxGettable{
  public:
    virtual bool verifyTx(const Tx & t) const noexcept=0;
    virtual bool addTx(const Tx & t) noexcept=0;
  };

  /**
   * @brief The interface of pool exposed to sealer.
   *
   * The sealer is supposed to make a BlkForConsensus with the BlkNumber and the
   * Tx hashes obtained from here.
   *
   *  This need to be thread-safe.
   */
  class IForSealerTxHashesGettable{
  public:
    virtual vector<hash256> getTxHashesForSeal() noexcept=0;
  };

  /**
   * @brief The interface that can be queried by rpc.
   *
   * The interface that starts with `IForRpc` (usually) should inherit this.
   *
   * ü¶ú :Of course, there're exceptions. `IForRpcNetworkable` for example is
   * just utility function that used by RPC
   */
  class IForRpc{
  public:
    virtual string info() noexcept=0;
  };

  /**
   * @brief The interface of the blockchain world exposed to RPC.
   *
   * This should be the only interface that the RPC can use to `change` the
   * world state.
   */
  class IForRpcTxsAddable: public virtual IForRpc{
  public:
    virtual bool addTxs(vector<Tx> && txs) noexcept=0;
  };


  /**
   * @brief The interface of mempool for LightExeForCnsss.
   * 
   * ü¶ú : This is the interface for the LightExeForCnsss to wash the txs. It
   * ensures that the hash is not used twice. This in fact will just touch `pool.txhs`.
   */
  class IForLightExeTxWashable{
  public:
    virtual void washTxs(vector<Tx> & txs) noexcept = 0;
  };

} // namespace weak

/**
 * @brief Some helper functions for stl
 */
namespace std {

  // ü¶ú: help std::less to use set<address>, converts to uint256 and compare.
  template<>
  struct less<evmc::address>{
    bool operator()(const evmc::address & l,
                    const evmc::address & r) const{
      intx::uint256 li = intx::be::load<intx::uint256,20>(l.bytes);
      intx::uint256 ri = intx::be::load<intx::uint256,20>(r.bytes);
      return li < ri;
    };
  };

  // ü¶ú: help std::less to use set<address>, converts to uint256 and compare.
  template<>
  struct less<ethash::hash256>{
    bool operator()(const ethash::hash256 & l,
                    const ethash::hash256 & r) const{
      intx::uint256 li = intx::be::load<intx::uint256,ethash::hash256>(l);
      // ü¶ú : load a type which hash `.bytes` fields. ethash::hash256 is such a
      // type.
      intx::uint256 ri = intx::be::load<intx::uint256,ethash::hash256>(r);
      return li < ri;
    };
  };


  // ü¶ú Define this to help ostream to display ethash_hash256 == ethash::hash256
  ostream& operator<<(ostream& os, const ethash_hash256& h){
    // os << intx::be::load<intx::uint<256>,ethash_hash256>(h);
    os << weak::hashToString(h);
    return os;
  };


  // ü¶ú Define this to help ostream to display evmc::bytes_view =
  // std::basic_string_view<uint8_t>
  ostream& operator<<(ostream& os, const std::basic_string_view<uint8_t>& a){
    // os << intx::be::load<intx::uint<256>,evmc::bytes32>(a);
    os << evmc::hex(a);         // bytes_view ‚áí string
    return os;
  };



  /*
    Hash operator template specialization for ethash_hash256. Needed for
    unordered containers.

    ü¶ú : This is just the hash function defined in evmc.hpp. But the structure
    of ethash_hash256 and evmc::bytes32 are so similar, we can just kinda re-use
    that.
   */
  template <>
  struct hash<ethash_hash256>
  {
    /// Hash operator using FNV1a-based folding.
    constexpr size_t operator()(const ethash_hash256& s) const noexcept
    {
      using namespace evmc;
      using namespace fnv;
      return static_cast<size_t>(
                                 fnv1a_by64(fnv1a_by64(fnv1a_by64(fnv1a_by64(fnv::offset_basis, load64le(&s.bytes[0])),
                                                                  load64le(&s.bytes[8])),
                                                       load64le(&s.bytes[16])),
                                            load64le(&s.bytes[24])));
    }
  };
}


// Teach C++ to compare things
bool operator==(const ethash_hash256 &l, const ethash_hash256 &r){
  return std::equal(std::begin(l.bytes),
                    std::end(l.bytes) ,
                    std::begin(r.bytes));
};
bool operator!=(const ethash_hash256 &l, const ethash_hash256 &r){
  return not (l == r);
};
