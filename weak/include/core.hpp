#pragma once
#include <algorithm>
// using std::string;

#include "core0.hpp"

namespace weak {

  using boost::lexical_cast;
  using std::function;




  // {{{ Interfaces


  /**
   * @brief Representing a type that can provide Acn.
   * The set of accounts is the canonical world state.
   */
  class IAcnGettable{
  public:
    virtual optional<Acn> getAcn(evmc::address addr) const noexcept=0;
  };


  /**
   * @brief A state change, should be generated by executor.
   */

  struct StateChange{bool del=false; string k; string v;};

  /**
   * @brief The interface drawn from `IWorldChainStateSettable`.
   *
   * ü¶ú : This is for RPC for now.
   */
  class IChainDBGettable {
  public:
    virtual optional<string> getFromChainDB(const string k) const =0;
  };

  /**
   * @brief The interface that `WorldStorage` exposes to `CoreManager`. It
   * allows the `CoreManager` to change
   *   - the *chain state* (e.g. Transaction info, Block info stored in chainDB)
   *   _ the *world state* (stored in stateDB)
   *
   *   ü¶ú: We see that the `CoreManager` is able to read/write chainDB (no
   *   deletion). This agree with fact that "blockchain is append only". On the
   *   other hand, StateDB can only be write/delete by the `CoreManager` because
   *   the state only need to be visible to the execution module.
   *
   *   üê¢: Are U sure that making the StateDB write-only to `CoreManager` is not
   *   being lazy?
   *
   *   ü¶ú: No.
   */
  class IWorldChainStateSettable: public virtual IChainDBGettable {
  public:
    virtual bool setInChainDB(const string k, const string v) =0;

    /// Apply the journal (state changes) to the stateDb, usually it's one
    /// journal per Blk.
    virtual bool applyJournalStateDB(const vector<StateChange> & j)=0;
  };

  /**
   * @brief The interface that `WorldStorage` exposes to get a series of keys
   * with certain prefix in the DB.
   *
   * üê¢ : This interface is created here initially for the initializer, who
   * needs to get all keys start which "/tx/" in order to figure out what Txs
   * have been written to the chain.
   */
class IChainDBPrefixKeyGettable {
public:
  virtual vector<string> getKeysStartWith(string_view prefix)const =0;
};

  /**
   * @brief The interface that sticks two interfaces.
   *
   * ü¶ú : Why?
   *
   * üê¢ : Sometimes it's easier to pass this around in functions. This is
   * created for `init`.
   */
class IChainDBGettable2 :public virtual IChainDBPrefixKeyGettable,
                         public virtual IChainDBGettable{};


  // }}}



class ITxExecutable {
  public:
    /**
     * @brief Probably the most important function that the execution module expose.
     *
     * If the execution is successful, a series of state-changes (called
     * "journal") and the execution-result is returned.
     *
     * @param w The read-only stateDb (world state).
     * @param t The transaction to be executed.
     * @return the pair (journal,result). {} if the execution fails.
     */
    virtual optional<tuple<vector<StateChange>,bytes>> executeTx(IAcnGettable * const w,
                                                                 const Tx & t) const noexcept = 0;
    // determine the type of tx: CREATE/CALL
    // Initialize host with the stateDb
    // Make VM
    // Execute and get result
    // If successful : make_tuple
  };


  // using std::move;

  class BlkHeader: virtual public IJsonizable {
  public:
    uint64_t number;
    /// empty for genesis block
    hash256 parentHash;
    BlkHeader() = default;
    BlkHeader(const uint64_t n,const hash256 p): number(n),parentHash(p){};

    // hash256 hash;
    virtual hash256 hash() const {
      // ü¶ú : we kinda have to provide a default implementation, because if we
      // wanna jsonize it, it must have a default, ctor...
      BOOST_THROW_EXCEPTION(std::runtime_error("hash() not implemented for BlkHeader"));
    }

    json::value toJson() const noexcept override {
      return json::value_from(*this);
    }

    bool fromJson(const json::value &v) noexcept override {

      BOOST_LOG_TRIVIAL(debug) << format("Forming BlkHeader from Json");
      try {
        optional<hash256> oh;
        // json::object const& o = v.as_object();
        this->number = value_to<uint64_t>(v.at("number"));
        string p,h;
        p= value_to<string>(v.at("parentHash"));

        // <2024-02-06 Tue> ü¶ú : change hash to method
        // h= value_to<string>(v.at("hash"));
        // oh = evmc::from_hex<hash256>(h);
        // if (not oh) BOOST_THROW_EXCEPTION(std::runtime_error("Invalid hash = " + h));
        // this->hash = oh.value();

        oh = evmc::from_hex<hash256>(p);
        if (not oh) BOOST_THROW_EXCEPTION(std::runtime_error("Invalid hash = " + h));
        this->parentHash = oh.value();
      }catch (std::exception &e){
        BOOST_LOG_TRIVIAL(error) << format("‚ùåÔ∏è error parsing json: %s") % e.what();
        return false;
      }

      // BOOST_LOG_TRIVIAL(debug) << format("üê∏ BlkHeader-%d fromed from Json") % this->number;
      return true;
    }
  };

  class Blk: public BlkHeader
           ,virtual public IJsonizable
           ,public ISerializableInPb<hiPb::Blk>
           ,virtual public ISerializable
  {
  public:
    /*
      message BlkHeader {uint64 number = 1; bytes parentHash = 2; bytes hash = 3;}

      message Blk {BlkHeader header = 1; repeated Tx txs = 2;} // []
     */
    // --------------------------------------------------
    //<2024-01-30 Tue> ü¶ú : let's add some pb
    void fromPb(const hiPb::Blk & pb) override{
      BOOST_LOG_TRIVIAL(debug) << format("Forming Blk from pb");
      // 1. form the BlkHeader part
      // --------------------------------------------------
      this->number = pb.header().number();

      string s = pb.header().parenthash();   // should be hash256 = 32 bytes

      // BOOST_ASSERT(s.size() == 32); // throws my_assertion_error
      this->parentHash = weak::fromByteString<hash256>(s); // may throw

      // 2. form the txs part
      // --------------------------------------------------
      for (const hiPb::Tx & tx : pb.txs()){
        Tx t;
        t.fromPb(tx);          // may throw
        this->txs.push_back(t);
      }
    }

    hiPb::Blk toPb() const override {
      hiPb::Blk pb;

      // set the header
      pb.mutable_header()->set_number(this->number);
      pb.mutable_header()->set_parenthash(weak::toByteString<hash256>(this->parentHash));

      // set the txs
      for (const Tx& tx : txs){
        pb.add_txs()->CopyFrom(tx.toPb());
      }
      return pb;
    }

    //<2024-01-30 Tue>
    // --------------------------------------------------


    Blk() = default;

    /**
     * @brief Construct the Blk and calculate the hash.
     *
     * In fact, most of the time the next ctor is used to make a `Blk` from
     * `BlkForConsensus`
     */
    Blk(const uint64_t n,const hash256 p,vector<Tx> t):
      BlkHeader(n,p),
      txs(t)
    {
      BOOST_LOG_TRIVIAL(info) << format("Making block-%d,\n\tparentHash=%s,\n\ttx size=%d")
        % number % hashToString(parentHash) % txs.size();
    }

    hash256 hash() const noexcept override {
      // Calculate hash based on the hashes of txs
      // TODO: ü¶ú For now, we use serial hash, later should be changed to Merkle tree.
      hash256 h = this->parentHash;
      static uint8_t s[64];     // a buffer for hashing
      for (const Tx& tx : this->txs){
        // BOOST_LOG_TRIVIAL(debug) << format("Hashing for tx-%d") % tx.nonce;
        std::copy_n(std::cbegin(tx.hash().bytes),32,s);
        std::copy_n(std::cbegin(h.bytes),32,s + 32);
        // s[:32] = tx.hash; s[32:] = h
        h = ethash::keccak256(reinterpret_cast<uint8_t*>(s),64);
        // BOOST_LOG_TRIVIAL(debug) << format("Now hash is %s") % hashToString(h);
      }
      return h;
    }

    vector<Tx> txs;
    ADD_TO_FROM_STR_WITH_JSON_OR_PB
    json::value toJson() const noexcept override {
      return json::value_from(*this);
    }

    bool fromJson(const json::value &v) noexcept override {

      // Parse number
      BOOST_LOG_TRIVIAL(debug) << format("Forming Blk from Json");

      if (not BlkHeader::fromJson(v)) return false;

      try {
        // json::object const& o = v.as_object();
        this->txs = value_to<vector<Tx>>(v.at("txs"));
        // boost::json knows about vector

      }catch (std::exception &e){
        BOOST_LOG_TRIVIAL(error) << format("‚ùåÔ∏è error parsing json: %s") % e.what();
        return false;
      }

     BOOST_LOG_TRIVIAL(debug) << format("üå± Blk-%d fromed from Json") % this->number;
      return true;
    }

  };

  // json functions for BlkHeader
  // ü¶ú : Defining this method allows us to use json::serialize(value_from(t))
  void tag_invoke(json::value_from_tag, json::value& jv, BlkHeader const& b ){
    jv = {
      {"number", b.number},
      {"hash", hashToString(b.hash())},
      {"parentHash", hashToString(b.parentHash)},
      // {"txs", json::value_from(b.txs)}
      /* ü¶ú : boost:json knows about std::vector, they turn it into array*/
    };
  };

  // json functions for Blk
  // ü¶ú : Defining this method allows us to use json::serialize(value_from(t))
  void tag_invoke(json::value_from_tag, json::value& jv, Blk const& b ){
    // jv = {
    //   {"number", b.number},
    //   {"hash", hashToString(b.hash)},
    //   {"parentHash", hashToString(b.parentHash)},
    //   {"txs", json::value_from(b.txs)}
    //   /* ü¶ú : boost:json knows about std::vector, they turn it into array*/
    // };

    // BOOST_LOG_TRIVIAL(debug) << format("Now json: %s") % json::serialize(jv);
    jv = json::value_from((const BlkHeader &) b);
    // BOOST_LOG_TRIVIAL(debug) << format("Now json: %s") % json::serialize(jv);
    jv.as_object()["txs"] = json::value_from(b.txs);
    // BOOST_LOG_TRIVIAL(debug) << format("Now json: %s") % json::serialize(jv);
    /* ü¶ú : boost:json knows about std::vector, they turn it into array*/

  };

  // This helper function deduces the type and assigns the value with the matching key
  // ü¶ú : Defining this allows us to use json::value_to<A>
  // Blk tag_invoke(json::value_to_tag<Blk>, json::value const& v ) noexcept{
  //   Blk b;
  //   if (b.fromJson(v)) return b;
  //   return {};
  // }
  // ü¶ú ^^^ above is replaced by the following
  ADD_FROM_JSON_TAG_INVOKE(Blk);
  ADD_FROM_JSON_TAG_INVOKE(BlkHeader);



  /**
   * @brief The type that can get Tx by the corresponsing hash.
   *
   * This is usually used by a `BlkForConsensus` to convert to an actual `Blk`.
   */
  class IByHashTxGettable{
  public:
    virtual optional<Tx> getTxByHash(hash256 h) noexcept=0;
  };

  /**
   * @brief The interface of pool exposed to consensus's executor.
   *
   * ü¶ú : This is pretty much everything the consensus's executor need from pool.
   */
  class IPoolSettable : public virtual IByHashTxGettable{
  public:
    virtual bool verifyTx(const Tx & t) const noexcept=0;
    virtual bool addTx(const Tx & t) noexcept=0;
  };

  /**
   * @brief The interface of pool exposed to sealer.
   *
   * The sealer is supposed to make a BlkForConsensus with the BlkNumber and the
   * Tx hashes obtained from here.
   *
   *  This need to be thread-safe.
   */
  class IForSealerTxHashesGettable{
  public:
    virtual vector<hash256> getTxHashesForSeal() noexcept=0;
  };

  /**
   * @brief The interface that can be queried by rpc.
   *
   * The interface that starts with `IForRpc` (usually) should inherit this.
   *
   * ü¶ú :Of course, there're exceptions. `IForRpcNetworkable` for example is
   * just utility function that used by RPC
   */
  class IForRpc{
  public:
    virtual string info() noexcept=0;
  };

  /**
   * @brief The interface of the blockchain world exposed to RPC.
   *
   * This should be the only interface that the RPC can use to `change` the
   * world state.
   */
  class IForRpcTxsAddable: public virtual IForRpc{
  public:
    virtual bool addTxs(vector<Tx> && txs) noexcept=0;
  };

}

/**
 * @brief Some helper functions for stl
 */
namespace std {

  // ü¶ú: help std::less to use set<address>, converts to uint256 and compare.
  template<>
  struct less<evmc::address>{
    bool operator()(const evmc::address & l,
                    const evmc::address & r) const{
      intx::uint256 li = intx::be::load<intx::uint256,20>(l.bytes);
      intx::uint256 ri = intx::be::load<intx::uint256,20>(r.bytes);
      return li < ri;
    };
  };

  // ü¶ú: help std::less to use set<address>, converts to uint256 and compare.
  template<>
  struct less<ethash::hash256>{
    bool operator()(const ethash::hash256 & l,
                    const ethash::hash256 & r) const{
      intx::uint256 li = intx::be::load<intx::uint256,ethash::hash256>(l);
      // ü¶ú : load a type which hash `.bytes` fields. ethash::hash256 is such a
      // type.
      intx::uint256 ri = intx::be::load<intx::uint256,ethash::hash256>(r);
      return li < ri;
    };
  };


  // ü¶ú Define this to help ostream to display ethash_hash256 == ethash::hash256
  ostream& operator<<(ostream& os, const ethash_hash256& h){
    // os << intx::be::load<intx::uint<256>,ethash_hash256>(h);
    os << weak::hashToString(h);
    return os;
  };


  // ü¶ú Define this to help ostream to display evmc::bytes_view =
  // std::basic_string_view<uint8_t>
  ostream& operator<<(ostream& os, const std::basic_string_view<uint8_t>& a){
    // os << intx::be::load<intx::uint<256>,evmc::bytes32>(a);
    os << evmc::hex(a);         // bytes_view ‚áí string
    return os;
  };



  /*
    Hash operator template specialization for ethash_hash256. Needed for
    unordered containers.

    ü¶ú : This is just the hash function defined in evmc.hpp. But the structure
    of ethash_hash256 and evmc::bytes32 are so similar, we can just kinda re-use
    that.
   */
  template <>
  struct hash<ethash_hash256>
  {
    /// Hash operator using FNV1a-based folding.
    constexpr size_t operator()(const ethash_hash256& s) const noexcept
    {
      using namespace evmc;
      using namespace fnv;
      return static_cast<size_t>(
                                 fnv1a_by64(fnv1a_by64(fnv1a_by64(fnv1a_by64(fnv::offset_basis, load64le(&s.bytes[0])),
                                                                  load64le(&s.bytes[8])),
                                                       load64le(&s.bytes[16])),
                                            load64le(&s.bytes[24])));
    }
  };
}


// Teach C++ to compare things
bool operator==(const ethash_hash256 &l, const ethash_hash256 &r){
  return std::equal(std::begin(l.bytes),
                    std::end(l.bytes) ,
                    std::begin(r.bytes));
};
bool operator!=(const ethash_hash256 &l, const ethash_hash256 &r){
  return not (l == r);
};
